/*
 * Copyright (c) 2020 Xilinx Inc. All rights reserved.
 *
 * Author:
 *       Appana Durga Kedareswara Rao <appanad.durga.rao@xilinx.com>
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/dts-v1/;

/ {
        compatible = "system-device-tree-v1";
        lops {
                // compatible = "system-device-tree-v1,lop";
                lop_0 {
                        // node name modify
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/cpus-a72@0/::/cpus/";
                };
                lop_1 {
                        // modify to "nothing", is a remove operation
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/cpus-r5@3::";
                };
                lop_2 {
                        // modify to "nothing", is a remove operation
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/cpus_microblaze@1::";
                };
                lop_3 {
                        // modify to "nothing", is a remove operation
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/cpus_microblaze@2::";
                };
                lop_4 {
                        // modify to "nothing", is a remove operation
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/amba_rpu::";
                };
                lop_5 {
                      compatible = "system-device-tree-v1,lop,select-v1";
                      // clear any old selections
                      select_1;
                      select_2 = "/cpus/.*:compatible:.*arm,cortex-a72.*";
                      select_3 = "/.*:status:.*okay.*";
                      select_4 = "/.*:device_type:.*memory.*";
                };
                lop_6 {
                        // modify to "nothing", is a remove operation
                        compatible = "system-device-tree-v1,lop,modify";
                        modify = "/memory@fffc0000::";
                };
                lop_8 {
                      compatible = "system-device-tree-v1,lop,code-v1";
                      code = "
                          assist_dir = os.path.dirname(os.path.realpath(__file__)) + '/assists/'
                          sys.path.append(assist_dir)
                          from domain_access import get_domain_nodes, get_mem_nodes, update_mem_node
                          from baremetalconfig_xlnx import scan_reg_size

                          domain_nodes = get_domain_nodes(tree)
                          invalid_phandles = []
                          shared_phandles = []
                          linux_mem_domain = []
                          for domain_node in domain_nodes:
                              linux_domain = []
                              try:
                                  if re.search('linux', domain_node['os,type'].value):
                                      linux_domain = domain_node
                                      linux_mem_domain = domain_node
                              except:
                                  try:
                                      if domain_node['cpus'].value:
                                          print('ERROR: os,type property is missing in the domain', domain_node.name)
                                  except:
                                      pass

                              if linux_domain:
                                  try:
                                      shared_phandles.extend(domain_node['access'].value)
                                  except:
                                      pass
                                  try:
                                      rsc_domain = domain_node['include'].value
                                      for rsc in rsc_domain:
                                          match = [node for node in domain_nodes if node.phandle == rsc]
                                          if match:
                                              try:
                                                  shared_phandles.extend(match[0]['access'].value)
                                              except:
                                                  pass
                                  except:
                                      pass
                              else:
                                  try:
                                      for phandle in domain_node['access'].value:
                                          invalid_phandles.append(phandle)
                                  except:
                                      pass

                          node_list = []
                          address_map = node.parent['address-map'].value
                          na = node.parent['#ranges-address-cells'].value[0]
                          ns = node.parent['#ranges-size-cells'].value[0]
                          cells = na + ns
                          phandles = []
                          tmp = na
                          while tmp < len(address_map):
                              phandles.append(address_map[tmp])
                              tmp = tmp + cells + na + 1

                          phandles = list(dict.fromkeys(phandles))
                          invalid_phandles_list = [phandle for phandle in invalid_phandles if phandle not in shared_phandles]
                          valid_phandles = [phandle for phandle in phandles if phandle not in invalid_phandles_list]
                          for s in tree.__selected__:
                              if not re.search('cpu.*', s.abs_path):
                                  node_list.append(s)
                          # Delete the unmapped nodes for a72
                          invalid_nodes = []
                          for node1 in node_list:
                              if re.search('xlnx,axi-bram-ctrl', node1['compatible'].value[0]):
                                  invalid_nodes.append(node1)
                          for node1 in node_list:
                              match = 0
                              for handle in valid_phandles:
                                  if handle == node1.phandle:
                                      match += 1
                              if match == 0:
                                  invalid_nodes.append(node1)
                          for node1 in invalid_nodes:
                              tree.delete(node1)

                          # Memory Domain handling
                          if linux_mem_domain:
                              try:
                                  has_addr = linux_mem_domain['memory'].value
                              except:
                                  has_addr = []

                              shared_mem = []
                              try:
                                  rsc_domain = linux_mem_domain['include'].value
                                  for rsc in rsc_domain:
                                      match = [node for node in domain_nodes if node.phandle == rsc]
                                      if match:
                                          try:
                                              shared_mem = match[0]['memory'].value
                                          except:
                                              pass
                              except:
                                  pass

                              if has_addr:
                                  start_addr = has_addr[0]
                                  mem_nodes = get_mem_nodes(tree)
                                  for node1 in mem_nodes:
                                      reg, size = scan_reg_size(node1, node1['reg'].value, 0)
                                      if start_addr in range(reg, reg+size) and shared_mem:
                                          linux_mem_domain['memory'].value.extend(shared_mem)
                                          modify_val = update_mem_node(node1, linux_mem_domain['memory'].value)
                                          node1['reg'].value = modify_val
                                      elif start_addr in range(reg, reg+size):
                                          modify_val = update_mem_node(node1, linux_mem_domain['memory'].value)
                                          node1['reg'].value = modify_val
                          for domain_node in domain_nodes:
                              tree.delete(domain_node)
                      ";
                };
		lop_9 {
			compatible = "system-device-tree-v1,lop,code-v1";
			code = "
                        n = node.tree['/amba_pl']
                        for i in n.subnodes():
                            if i.propval('compatible') == ['xlnx,axi-dma-mm2s-channel'] or i.propval('compatible') == ['xlnx,axi-dma-s2mm-channel']:
                                tree.delete(i)
                        n = node.tree['/amba']

                        tcm_str = 'xlnx,psv-r5-tcm'

                        for i in n.subnodes():
                            if len(i.propval('compatible')) == 1 and tcm_str in i.propval('compatible')[0]:
                                tree.delete(i)
                            elif len(i.propval('compatible')) > 1:
                                for j in i.propval('compatible'):
                                    if tcm_str in j:
                                        tree.delete(i)
			";
		};

        };
};
